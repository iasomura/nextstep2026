# 研究日誌 2026-01-17

## 本日の作業

### Handoffサンプルの分類戦略研究

Stage3 AI Agentの性能問題を受け、Handoffサンプルを効果的に分類するための特徴量とルールを調査した。

---

## VirusTotalによるFN検証（ラベル正当性確認）

### 目的

FN（見逃し）サンプルのラベル（フィッシング）が正しいかをVirusTotalで検証した。

**注意:** VirusTotalは外部依存のため論文の手法には組み込めないが、データセットラベルの妥当性検証として使用。

### 検証結果

| 項目 | 結果 |
|------|------|
| 検証サンプル数 | 200件 (FN からランダム抽出) |
| **VT検出あり (malicious > 0)** | **178件 (89%)** |
| VT検出なし | 22件 (11%) |
| 平均malicious検出数 | 9.8 |

### VT検出なしの22件

```
ruralmi.com, ridgelinebooking.com, ashleytevatia.com, xazlty.com,
www.wargo.jp, ea-quality.com, vsbd.85953.cn, daycom.cn,
m-creativestudio.com, materialsacademy.com, isikserradyator.com,
satsumatsu.com, tg1.com.cn, usna85.com, buscoverytours.com,
gtfotv.com, colocationquimper.com, olivia.paradox.ai,
kucointokencode.com, caronl.com, senva.com.cn, andreawales.com
```

### 結論

- **89%のFNはVirusTotalでフィッシングとして検出済み**
- データセットのラベルは妥当
- 本システムの見逃しは検出手法の限界（外部脅威インテリジェンスでは検出可能）

---

## Handoff特徴量の識別力分析

### 問題の背景

Stage3 AI AgentがStage1より性能が低い根本原因を調査した。

**仮説:** Handoffに渡されるサンプルでは、通常の特徴量が識別力を失っている可能性がある。

### 分析対象

- **Handoffサンプル数:** 17,859件
- **内訳:** FN (phishing) = 3,216件, FP (benign) = 14,643件

### Cohen's d による識別力評価

#### 識別力がある特徴量（Handoff内）

| 特徴量 | FN平均 | FP平均 | Cohen's d | 備考 |
|--------|--------|--------|-----------|------|
| **ml_probability** | 0.553 | 0.091 | **1.759*** | 最も重要 |
| **high_ml_phish (>=0.50)** | 57.1% | 2.8% | **1.522*** | バイナリ化 |
| **tld_dangerous** | 29.5% | 5.5% | **0.813*** | TLDシグナル |
| **uncertainty** | 0.247 | 0.105 | **0.741*** | Stage1不確実性 |

#### 識別力を失う特徴量（Handoff内）

| 特徴量 | FN値 | FP値 | Cohen's d | 問題 |
|--------|------|------|-----------|------|
| safe_benign | 0% | 0% | 0.000 | **全てゼロ** |
| safe_benign_cert | 0% | 0% | 0.000 | **全てゼロ** |
| is_free_ca | 89.2% | 90.8% | 0.076 | 両クラス ~90% |
| is_letsencrypt | 82.5% | 85.7% | 0.049 | 両クラス ~80% |
| brand_hit | 15.8% | 14.7% | 0.044 | ほぼ同率 |

### 重要な発見

**certificate_analysis_report.md で高い識別力を示した特徴量が、Handoff内では機能しない。**

理由: Stage1で明確なサンプルが除外され、残りは「両クラスとも曖昧」なサンプルのみ。

```
全データセット:
  LE証明書率: Phishing 85.9% vs Benign 0% → d = ∞

Handoff内:
  LE証明書率: FN 82.5% vs FP 85.7% → d = 0.049 (無効)
```

---

## 証明書発行日（cert_age_days）の発見

### 新規特徴量の調査

既存特徴量がHandoffで機能しないため、証明書の時間的特徴を調査した。

### cert_age_days の識別力

| 指標 | FN (phishing) | FP (benign) | Cohen's d |
|------|---------------|-------------|-----------|
| **cert_age_days** | 449.8日 | 248.0日 | **0.745*** |
| **old_cert (>365日)** | 49.3% | 3.4% | **1.222*** |
| **very_old_cert (>730日)** | 26.9% | 0.9% | **1.173*** |

**発見:** フィッシングサイトの証明書は正規サイトより平均で約200日古い。

### 分布比較

```
cert_age_days 分布:
                    FN (phishing)    FP (benign)
0-90日   (新しい)    24.9%            58.7%
91-365日 (中間)      25.8%            37.9%
366-730日 (古い)     22.4%            2.5%
731日+   (非常に古い) 26.9%            0.9%
```

### 解釈の考察

「古い証明書」が意味するものは2つの可能性がある:

1. **長期間運営フィッシング**: 検出を逃れて長期運営しているフィッシングサイト
2. **乗っ取られた正規サイト**: 正規サイトが攻撃され、既存の古い証明書を継承

### 調査: 乗っ取り vs 専用フィッシング

old_cert (>365日) の FN 1,399件を分析:

| 分類 | 件数 | 割合 | 判定基準 |
|------|------|------|----------|
| **ブランド偽装確定** | 123件 | **8.8%** | ドメインにブランド名含む |
| **高SAN (乗っ取り疑い)** | 203件 | **14.5%** | SAN >= 5 (共有サーバー兆候) |
| **判定困難** | 1,073件 | **76.7%** | 上記どちらでもない |

### 高SANサンプルの詳細分析

「乗っ取り疑い」の高SANサンプル（203件）でも:

| 指標 | 高SAN FN | 高SAN FP | 差 |
|------|----------|----------|-----|
| cert_age_days | **455.5日** | 249.9日 | +205.6日 |

**結論:** 高SAN（共有サーバー）でも、フィッシングの証明書は正規より古い。

### 最終解釈

どちらの解釈が正しいかは確定できないが:

- **長期運営フィッシング説**: フィッシングは発見されにくいドメインを長期使用
- **乗っ取り説**: 古いサイトほど脆弱性が蓄積して乗っ取られやすい

**重要:** いずれの解釈でも、cert_age_days は有効な識別特徴量。

---

## 分類戦略の提案

### 特徴量の組み合わせ

| 戦略 | 条件 | FN Recall | FPR | Precision |
|------|------|-----------|-----|-----------|
| ML のみ | ml >= 0.50 | 57.1% | 2.8% | 78.6% |
| cert_age のみ | cert_age > 365 | 49.3% | 3.4% | 72.1% |
| **組み合わせ** | (ml>=0.5) OR (ml>=0.2 AND cert>365) | **63.8%** | **2.2%** | **86.2%** |

### 推奨ルール

```python
def classify_handoff(ml_prob, cert_age_days):
    # Strategy 4: ML + cert_age combination
    if ml_prob >= 0.50:
        return "phishing"
    elif ml_prob >= 0.20 and cert_age_days > 365:
        return "phishing"
    elif ml_prob >= 0.10 and cert_age_days > 730:
        return "phishing"
    else:
        return "benign"
```

**期待効果:**
- FN Recall: 63.8% (3,216件中 2,052件を検出)
- FPR: 2.2% (14,643件中 322件が誤検出)
- Precision: 86.2%

---

## Stage3 AI Agent の問題根本原因

### 分析結果

Stage3 AI Agent (Qwen3-4B, 14B) の性能低下の根本原因:

1. **同じ特徴量を使用**: Agent のツール (brand_impersonation_check, certificate_analysis) は Stage1 が失敗した特徴量を再利用
2. **cert_age_days 未使用**: この有効な特徴量が Agent に渡されていない
3. **LLM の過敏反応**: ドメイン名パターンを過度にリスクと判定

### 改善案

| 優先度 | 改善内容 |
|--------|----------|
| **高** | cert_age_days を Stage3 ツールに追加 |
| **高** | ml_probability を判定の基準として活用 |
| **中** | old_cert ルールの実装 |
| **低** | LLM プロンプトの調整 |

---

## 本日の成果まとめ

### 発見

1. **cert_age_days が Handoff 最強の識別特徴量** (d=0.745)
   - FN: 449.8日 vs FP: 248.0日
   - old_cert (>365日): FN 49.3% vs FP 3.4%

2. **既存特徴量が Handoff で機能しない理由**
   - Stage1 で明確なサンプルが除外済み
   - 残りは両クラスとも「曖昧」

3. **長期運営フィッシング vs 乗っ取り**
   - 8.8% がブランド偽装（専用フィッシング確定）
   - 14.5% が高SAN（乗っ取り疑い）
   - 76.7% は判定困難
   - **いずれの解釈でも cert_age_days は有効**

### 提案

ml_probability と cert_age_days の組み合わせルールにより:
- FN Recall: 63.8%
- Precision: 86.2%

の分類が可能。

---

## Stage3 実装: old_cert_phishing ルール

### 実装内容

cert_age_days を活用した新しいフィッシング検出ルールを Stage3 に実装した。

#### 1. certificate_analysis.py の変更

- `cert_age_days` を `cert_full_info_map` から読み込み
- `is_old_cert` (>365日)、`is_very_old_cert` (>730日) フラグを追加
- 設定パラメータ: `old_cert_days=365`, `very_old_cert_days=730`

#### 2. contextual_risk_assessment.py の変更

TLDリスクレベルに応じた閾値調整を実装:

```python
# 危険TLD（より積極的に検出）
if is_tld_dangerous:
    ml_threshold_old = 0.20
    age_threshold_old = 365
    ml_threshold_very_old = 0.10
else:
    # 非危険TLD（FP削減のため保守的）
    ml_threshold_old = 0.25
    age_threshold_old = 400
    ml_threshold_very_old = 0.15
```

ルール:
- ml >= 0.50: 既存の高MLルールで対応（old_cert信号を追加）
- ml >= threshold_old AND cert_age > age_threshold: 中ML + 古い証明書
- ml >= threshold_very_old AND cert_age > 730: 低ML + 非常に古い証明書

FP防止:
- `has_crl_dp` または `ov_ev_cert` がある場合はルールをスキップ

### 評価結果

#### ルールバリエーション比較

| バリエーション | FN検出 | FP | 精度 |
|---------------|--------|-----|------|
| V1 (元の固定閾値) | 324 | 30 | 91.5% |
| V2 (tld_dangerous必須) | 107 | 1 | 99.1% |
| V4 (age>400) | 297 | 22 | 93.1% |
| **V-TLD (TLD対応)** | **270** | **16** | **94.4%** |

#### 最終実装 (TLD対応ルール)

| 項目 | 危険TLD | 非危険TLD | 合計 |
|------|---------|-----------|------|
| FN検出 | 89/1,193 (7.5%) | 181/2,023 (8.9%) | **270/3,216 (8.4%)** |
| FP | 1/894 (0.1%) | 15/13,749 (0.1%) | **16/14,643 (0.1%)** |

**精度: 94.4%** (270 TP / (270 TP + 16 FP))

### 増分効果（Stage1 高MLルール除外）

ml>=0.5 の既存ルールを除いた、old_cert ルールによる純粋な追加効果:

- 追加FN検出: 270件
- 追加FP: 16件
- 増分精度: 94.4%

### 変更ファイル

| ファイル | 変更内容 |
|----------|----------|
| `phishing_agent/tools/certificate_analysis.py` | cert_age_days読み込み、old_cert判定追加 |
| `phishing_agent/tools/contextual_risk_assessment.py` | old_cert_phishingルール実装 |

---

## 証明書データ欠損問題の解決

### 問題

undetectable_fn_1111.csvの分析で、29件のサンプルに証明書データ欠損が発見された:
- `cert_issuer_org`, `cert_not_before`, `cert_not_after` が空欄
- `cert_age_days` が全て 0
- これらのドメインが `cert_full_info_map` に含まれていない

### 原因

`cert_full_info_map` がデータベースから生成されていたため、`prepared_data.pkl` に存在するドメインが含まれないケースがあった。

### 解決策

`02_main.py` で `cert_full_info_map` を `prepared_data.pkl` から直接生成するように変更:

1. **cert_full_info_map生成** (02_main.py)
   - 全サンプルの `cert_data` (DER形式バイト) をパース
   - `issuer_org`, `cert_age_days`, `not_before`, `not_after` 等を抽出
   - `cert_full_info_map` として保存

2. **証明書データフィルター**
   - パースに失敗したサンプルを Stage1 から除外
   - 設定: `stage1_require_cert_data: True`

3. **handoff への追加**
   - `cert_full_info_map` を handoff ペイロードに含める
   - Stage3 で確実に利用可能に

### 変更ファイル

| ファイル | 変更内容 |
|----------|----------|
| `02_main.py` | cert_full_info_map 生成、フィルター追加、handoff への保存 |

### 効果

- 全ドメインが `cert_full_info_map` に含まれる
- Stage3 の証明書分析が確実に機能する
- 29件の欠損問題が解消

---

## vLLM 自動管理機能

### 背景

02_main.py実行時、LLMブランドキーワード抽出にvLLMサーバーが必要だが、常時起動はGPUリソースを消費する。

### 実装

`VLLMManager`クラスを作成し、必要時のみ自動起動・停止:

```python
# scripts/vllm_manager.py
class VLLMManager:
    """Context manager for vLLM server lifecycle."""

    def __enter__(self):
        # サーバー起動、ヘルスチェック待機
        self.start()
        return self

    def __exit__(self, ...):
        # サーバー停止
        self.stop()
```

### 使用方法

```python
# 02_main.py で自動管理
if cfg.get('vllm_auto_manage', True):
    with VLLMManager(cfg):
        brand_keywords = extract_brands_via_llm(cfg)
```

### 設定

```python
{
    'vllm_auto_manage': True,        # 自動起動・停止を有効化
    'vllm_startup_timeout': 120,     # 起動待機タイムアウト(秒)
    'vllm_gpu_memory_utilization': 0.85,
}
```

### 動作

1. キャッシュ(`brand_keywords.json`)がある場合 → vLLM不要
2. キャッシュがない場合:
   - vLLMサーバー起動
   - ヘルスチェック待機
   - ブランドキーワード抽出
   - vLLMサーバー停止

### 変更ファイル

| ファイル | 変更内容 |
|----------|----------|
| `scripts/vllm_manager.py` | 新規作成: VLLMManagerクラス (Python用) |
| `scripts/run_full_pipeline.sh` | vLLM自動管理関数追加 (Bash用) |
| `02_main.py` | VLLMManager統合、設定追加 |

### run_full_pipeline.sh の使用方法

```bash
./scripts/run_full_pipeline.sh           # 全体実行 (vLLM自動管理)
./scripts/run_full_pipeline.sh --no-e2e  # evaluate_e2e.py以外
./scripts/run_full_pipeline.sh --no-vllm # vLLM自動管理を無効化
```

### vLLM管理タイミング

```
[1/9] 01_data_preparation.ipynb  ─┐
[2/9] 02_main.py                  │ vLLM不要
[3/9] 03_part1.ipynb              │ (02_main.pyはキャッシュ使用時不要)
[4/9] 03_part2.ipynb              │
[5/9] 03_part3.ipynb              │
[6/9] 04-1.ipynb                  │
[7/9] 04-2.ipynb                 ─┘

     ┌─── vLLM起動 ───┐
[8/9] 04-3.ipynb                  │ vLLM使用
[9/9] evaluate_e2e.py             │
     └─── vLLM停止 ───┘
```

---

## 次のステップ

1. ~~**cert_age_days を Stage3 に統合**~~ **完了**
   - ~~contextual_risk_assessment ツールに追加~~
   - ~~old_cert ルールの実装~~

2. ~~**証明書データ欠損問題の解決**~~ **完了**
   - ~~cert_full_info_map を prepared_data.pkl から生成~~
   - ~~handoff に含めて Stage3 へ渡す~~

3. ~~**vLLM自動管理**~~ **完了**
   - ~~必要時のみ起動、完了後停止~~

4. **パイプライン全体評価**
   - Stage3 Agent + old_cert ルールの統合評価
   - LLM判定との相互作用確認

4. **論文への反映**
   - cert_age_days の識別力を新規発見として記載
   - 「長期運営 vs 乗っ取り」の考察を追加
   - TLD対応ルールの設計思想
